# -*- coding: utf-8 -*-
"""analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1osb0xHEM2qLLoE_HoWDUjRhKwDGmK3z4

#HACETTEPE UNIVERSITY ELECTRICAL AND ELECTRONICS ENGINEERING
#ELE 489 HOMEWORK 1
ELİF SEDEF SEKKİN 2200357097

First we are strating by adding the libraries we will be using through our assignment.
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns


"""The following piece of code is a knn implementation with two different distance calculations and for different values of k (3,5,7,9)"""

#the knn implementation
from collections import Counter

def euclidean_distance (point1,point2):
  return np.sqrt(np.sum((np.array(point1)-np.array(point2))**2))     #a function for calculating Euclidean Distance

def manhattan_distance (point1,point2):
  return np.sum(np.abs(np.array(point1)-np.array(point2)))          #a function for calculating Manhattan Distance

def knn_predict_euclidean(training_data,training_labels,test_data,k):    #a function that makes the prediction with knn algorithm by using Euclidean Distance
  distances=[]
  for i in range(len(training_data)):
    dist = euclidean_distance(test_data,training_data[i])             #calling the euclidean distance function and giving the training data points and the test data point
    distances.append((dist,training_labels[i]))                       #adding the calculated distances with the classes of the training data to the distances list
  distances.sort(key = lambda x: x[0])                                #sorting the distances list by just looking at the calcolated distances
  k_nearest_labels=[]
  for i in range(k):
      label=distances[i][1]                                          #getting the labels of the first k elements
      k_nearest_labels.append(label)                                 #storing them in the list of k_nearest_labels
  counts=Counter(k_nearest_labels)
  most_common_label,_=counts.most_common(1)[0]                       #counting the labels to decide which one is the most common one among them
  return most_common_label                                           #then return that prediction you make


def knn_predict_manhattan(training_data,training_labels,test_data,k): #a function that makes the prediction with knn algorithm by using Manhattan Distance
  distances=[]
  for i in range(len(training_data)):
    dist = manhattan_distance(test_data,training_data[i])
    distances.append((dist,training_labels[i]))
  distances.sort(key = lambda x: x[0])
  k_nearest_labels=[]
  for i in range(k):
      label=distances[i][1]
      k_nearest_labels.append(label)
  counts=Counter(k_nearest_labels)
  most_common_label,_=counts.most_common(1)[0]
  return most_common_label




